GitFlow

Gitflow — лишь одна из многих методологий работы с Git.

Ключевые идеи, которые нужно запомнить о Gitflow:

    Данная модель отлично подходит для организации рабочего процесса на основе релизов.
    Работа по модели Gitflow предусматривает создание специальной ветки для исправления ошибок в рабочем релизе.

Последовательность действий при работе по модели Gitflow:

    Из ветки main создается ветка develop.
    Из ветки develop создается ветка release.
    Из ветки develop создаются ветки feature.
    Когда работа над веткой feature завершается, она сливается в ветку develop.
    Когда работа над веткой release завершается, она сливается с ветками develop и main.
    Если в ветке main обнаруживается проблема, из main создается ветка hotfix.
    Когда работа над веткой hotfix завершается, она сливается с ветками develop и main.



В этом документе мы рассмотрели рабочий процесс Git с функциональными ветками. Этот процесс помогает структурировать и отслеживать ветки, предназначенные для разработки бизнес-функций. Другие рабочие процессы Git, например Gitflow или рабочий процесс с форками, ориентированы на работу с репозиториями и могут использовать процесс Git с функциональными ветками для управления моделями ветвления данных. В этом документе был рассмотрен общий пример работы с кодом и вымышленный пример реализации рабочего процесса Git с функциональными ветками. Ниже приводится несколько ключевых особенностей рабочего процесса Git с функциональными ветками:

    ориентация на схемы работы с ветками;
    возможность использования другими рабочими процессами, предназначенными для работы с репозиториями;
    поддержка совместной работы с участниками команды посредством запросов pull и проверок слияния.

Использование git rebase на этапах проверки и слияния функциональной ветки создает в Git непрерывную историю слияния функций. Модель функционального ветвления — великолепный инструмент для совместной работы в командной среде.



Forking Workflow стратегии разработка ведется так, что есть два репозитория:

    Оригинальный репозиторий, в который будут смердживаться все изменения.
    Форк репозиторий (это копия оригинального репозитория во владении другого разработчика, который хочет внести изменения в оригинальный).

Пока звучит как-то странно, да?

Тем, кто уже сталкивался с open-source разработкой, этот подход уже знаком.
Такая стратегия дает следующее премущество: разработка может вестись в форк-репозитории и без предоставления прав на совместную разработку в оригинальном.

Разумеется, что владелец оригинального репозитория вправе отклонить предлагаемые изменения. Или согласиться и смерджить их.

Это удобно и владельцу оригинального репозитория, и разработчику, который хочет поучаствовать в создании какого-то продукта.

Например можно предложить изменения в ядро линукса. Если Линус решит, что они имеют смысл, изменения будут добавлены (!!!).
Пример The Forking Workflow
The Forking Flow применяется на GitHub’e в момент, когда есть какая-то библиотека, которую хочется использовать. В ней есть дефект, который мешает использовать ее полноценно.

Допустим, вы погрузились достаточно в проблему и знаете решение. При помощи The Forking Workflow стратегии можно решить эту задачу без предоставления прав для работы в оригинальном репозитории библиотеки.

Чтобы начать работу, нужно выбрать какой-то репозиторий, например, ядро Spring Framework, Находим в верхнем правом углу кнопку Fork и нажимаем ее:



GitHub Flow

К ней прилагается набор правил, которым нужно следовать:

    Код в master ветке должен быть не поломанным и готовым к развертыванию в любое время (то есть нельзя туда положить код, который помешает собрать проект и развернуть его на сервере).
    Когда планируется работа над новой функциональностью, необходимо создать новую ветку (feature ветку) на основе master ветки и дать ей понятное имя. Коммитить свой код локально и регулярно пушить свои изменения на эту же ветку в удаленный репозиторий.
    Открыть Pull-Request (что такое pull-request, можно почитать здесь), когда есть четкое ощущение, что работа готова и может быть смерджена в master ветку (или если уверенности нет, но хочется получить отзывы о проделанной работе).
    После того, как новую фичу в пул-реквесте заапрувили, ее можно смерджить в master ветку.
    Когда изменения смерджены в master ветку, их нужно развернуть на сервере немедленно.

По GitHub Flow получается, что прежде чем начать работу над чем-то новым, будь то исправление или новая фича, нужно создать новую ветку на основе master’а и дать ей подходящее имя.

Далее, начинается работа над реализацией. Нужно постоянно отправлять коммиты на удаленный сервер с тем же именем. Когда приходит понимание, что все готово, нужно создать пул-реквест в master ветку. Потом хотя бы один, а лучше — два человека должны посмотреть этот код и нажать Approve. Обычно обязательно должен посмотреть тимлид проекта и кто-то еще, и тогда уже можно завершать пул-реквест.

GitHub Flow еще известен тем, что драйвит Continuous Delivery(CD) на проекте. Потому что когда изменения заходят в master ветку, они должны сразу же быть развернуты на сервере.



Trunk Based Development


    Короткоживущие ветки. У нас любая ветка, которая создается (кроме мастера), живет не больше двух дней. Два дня и все, это уже не Trunk и все печально. Поэтому все ветки, кроме мастера, например, ветка релизная или для фичи живет не больше двух дней.

    Feature Flags:
	    Можем мержить и деплоить код, который еще не готов.
	    Можем делать A/B тесты.
	    Можем шарить код между недоработанными фичами.

    Branch By Abstraction.
	    У нас частые интеграции. У нас был continuous integration в индустрии, где мы пришли к тому, чтобы работать маленькими кусочками. И это ультимативный вариант, т. е. мы теперь все время работаем маленькими кусочками, даже микрокусочками.
	    Мы можем рефакторить так наше приложение постепенно. У нас нет такого, что мы за один раз должны переделать вообще все. Маленькие кусочки, маленькие итерации.
	    И это позволяет нам быстро переключаться между задачами. Например, мы делали одну штуку, а у нас сейчас аврал и надо что-то фиксить, мы можем спокойно вмержить то, что у нас уже было, переключиться на другую задачу. Это ничего не сломает. Наш pull request не будет потерян, забыт. И его можно будет легко проверить спустя 5 дней после того, как его написали, потому что они все маленькие.


    Continuous Code Review.
	    Как любое review оно дает нам шаринг знаний. Все программисты понимают, как код меняется. Мы переиспользуем код, советуем друг другу лучшие практики и т. д. И мы это делаем постоянно, каждые 10 минут фактически, с каждой абстракцией.
	    Можно использовать экстремальное программирование. Когда два человека все время пишут код вместе, тогда вам review не нужно, вы его делаете сразу. Соответственно, снижаете тех долга по причине того, что мы все смотрим.
	    И ускоряем поставку. Мы pull request готовим не днями. Мы сделали изменение, оно в prode через две минуты.


    И основная идея в том, что у нас теперь и мастер всегда готов к деплою, даже если в нем есть недописанные фичи. Он всегда – release ready и вообще не важно, что в нем.

    Это сложно потому что:
	    Во-первых, у вас должно быть высокое покрытие тестами, чтобы вы могли так делать. Чтобы вы могли все время мержить все свои изменения в мастер и при этом не бояться, что у вас что-то сломается, вам нужно высокое покрытие тестами.
	    Feature Flags потребуют изменений в инфраструктуре. Вы теперь должны кодом, переменными включать те фичи, которые вам нужны. И вам нужно написать код вокруг ваших …, Ansible-ролей и т. д., чтобы вы могли этим управлять.
	    Branch By Abstraction требует от вас навыка построения абстракции и декомпозиции ваших задач, чтобы бить это все на мелкие кусочки.


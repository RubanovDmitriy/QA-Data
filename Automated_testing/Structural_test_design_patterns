Структурные паттерны – Structural Patterns

    1. Page Object
    	Page Object (паттерн/шаблон проектирования, который используется в автоматизированном тестировании)
        Разделить технические детали (в данном случае, говоря про web, это элементы в браузере, элементы, выполняющие ту или иную функциональность),
        разнести и унести их из логики своих тестов, чтобы логика тестов осталась чистой и прозрачной, а эта информация хранилась где-то в другом месте.
        Избегание повторения кода.

    2. Fluent/Chain of invocations
        Методы вызываются последовательно, без объявления объекта.

    3. Factory/Page Factory
    	Page Factory (класс из библиотеки Selenium)

    	Запомните, что PageFactory инициализирует объекты/элементы страницы и обращается к ним, только когда в коде есть обращение к ним. Т.е. если в коде вы ни разу не обратились к какому-то объекту страницы, то его инициализация не производится хоть он и прописан в классе описания страницы. Эта важная особенность PageFactory. Можно работать без PageFactory, но тогда там происходит сразу инициализация всех объектов, находящихся в классе и если, инициализируя объект он не будет найден на открытой странице, то WebDriver выдаст исключение, что данный объект не найден на странице. Примеры без PageFactory я не разбираю, потому что работа без PageFactory доставляет массу неудобств.

    	В методе init() мы вызываем PageFactory.initElements(driver, this);. Драйвер не начинает искать элементы на странице сразу же, а ищет их как только мы обращаемся к полю класса. Например строка searchButton.click(); «превращается» в driver.findElement(By.cssSelector("input[type=\"submit\"]")).click();
		Плюсы:
        	1. Не нужно писать driver.findElements(...) и копипастить этот поиск по всему классу;
	    	2. Можно использовать аннотацию @CacheLookup: найдя элемент в первый раз, driver кэширует его и в будущем уже использует кэшированный объект, что даёт небольшой прирост в скорости тестов;
	    	3. Можно уйти от использования интерфейса WebElement и создать свои классы для элементов страницы типа Button, TextField и т.д.

	4. Page Element/Composite List of Items Link Menu Panel Checkbox
		Прописывание виджетов как вазовых классов, с дальнейшим наследованием под каждую страницу. Например форма, которая умеет делать действия, характерные для всех форм, — такие как submit, «введи в поле значение», validate

	5. Loadable Component
		Используется для решения проблематики
		Implicit Wait, или неявное ожидание. Implicit Wait можно использовать для:
			ожидания полной загрузки страницы — pageLoadTimeout();
			ожидания появления элемента на странице — implicitlyWait();
			ожидания выполнения асинхронного запроса — setScriptTimeout();

		Explicit wait, или явное ожидание, чаще используется для ожидания определенного условия, которое должно быть выполнено прежде, чем тест пойдет дальше.
			О явном ожидании стоит помнить следующие вещи:
			    ожидание сработает именно там, где оно указано;
			    как и неявному ожиданию, ему необходимо указать лимит времени;
			    ожидает выполнения необходимого условия;
			    ждет завершения Ajax request.

		Каждую страницу, отнаследовать от loadable component и перегрузить метод isLoaded, благодаря чему скроете это ожидание и специфицируете его для каждой страницы внутри самой страницы. В этом случае у вас будет инкапсулированная логика в одном месте – если вы одну и ту же страницу будете в пяти местах вызывать и нигде больше этот wait руками писать не придется. Вот для чего придуман и существует этот паттерн.

	6. Strategy
		Нужен, когда мы хотим иметь несколько реализаций одного и того же – либо последовательностей, либо действий. Мы можем подставлять туда эту реализацию в зависимости от контекста.
		По типу клиента (или по типу обрабатываемых данных) выбрать подходящий алгоритм, который следует применить.
		Если используется правило, которое не подвержено изменениям, нет необходимости обращаться к шаблону «стратегия».


Паттерны данных – Data Patterns

	7. Value Object
		Если у вас есть несколько объектов, объединенных между собой логически (например есть registerUser, и мы передаем туда пять параметров – имя, фамилию, возраст, роль и прочее)
		Это можно трансформировать, введя дополнительный ValueObject, который называется вполне логично user, и который агрегирует в себе всю эту информацию.
		ValueObject Immutable: после того, как он создается, его нельзя изменить, потому что в этом его задача, он служит для передачи данных из точки А в точку Б, а не для того чтобы быть модифицируемым или нести сторонние эффекты.

	8. Builder
		Отделяет конструирование сложного объекта от его представления так, что в результате одного и того же процесса конструирования могут получаться разные представления.
		    позволяет изменять внутреннее представление продукта;
		    изолирует код, реализующий конструирование и представление;
		    дает более тонкий контроль над процессом конструирования.


    9. Assert Object/Matchers
    	Необходимо воплощать наши ассерты в виде повторяющихся конструкций, которые позволят нам не писать такой ассерт в будущем, если он понадобится нам снова.

    10. Data Registry
    	Решает проблематику, зависимости тестов / тестовых данных. Подход Data Registry позволяет вам генерировать уникальные данные и следить за их уникальностью.

    11. Object Pool/Flyweight
    	Решает проблемы с объектами или наборами объектов, которые тяжеловесны в создании.
    	Браузеры не обязательно создавать прямо в тесте, вместо этого можно использовать Background Pool, в котором настроено необходимое вам количество браузеров, и в этом пуле, когда браузер в него возвращается – вы его очищаете, делаете еще что-то, но это все происходит в бэкграунде, в параллельных с выполнением ваших тестов потоках.
    	Можно иметь пул страниц и запрашивать страницу из него, что означает, что она там уже открыта и ждет вас в каком-то инстансе браузера, и вы уже начинаете свою логику с открытой страницы, а само открытие происходит в скрытом от вас бэкграундном процессе.

    12. Data Provider
		Если вы хотите сделать data-driven тесты, и хотели бы, чтобы одна и та же тестовая логика выполнялась с разными данными, для этого вы загружаете свои данные из какого-либо внешнего источника.


Technical Patterns - Технические паттерны служат для того, чтобы вынести технические аспекты отдельно от тестовой логики, и зачастую для обеспечения дополнительного низкоуровневого контроля над технической частью.

	13. Decorator
		Оборачивание функции в другую, для изменения её поведения, без изменения кода

	14. Proxy
		Паттерн, позволяющий вмешаться в процесс между вами и ещё кем-то, и внедрить туда любую логику, не затрагивая ни вас, ни его.
		В данном случае самый популярный способ – это использование HTTP proxy для ваших тестов, который позволяет гибко настроить, например, black-листы, и сказать, что когда мое приложение пойдет в твиттер, фейсбук и так далее, я верну такие-то закэшированные результаты или верну ничего. Иногда это единственный способ, благодаря которому вы можете проверить, например, какое-нибудь exceptional-поведение ваших внешних сервисов.

	15. Keyword Driven Testing
		Keyword Driven тест использует ключевые слова — команды, которые выглядят понятно для всех участников процесса. В них могут передаваться какие-то данные, и в этом случае ключевые слова реализуются людьми, которые знают технические детали, умеют их реализовать и присоединить к вашему приложению, а тесты может писать кто угодно – бизнес-аналитик, тестировщик без опыта автоматизации, фрейморк это позволяет.

	16. Behavior Specification
		Предлагает вместо тестов перейти на описание ожидаемого поведения. Таким образом мы будем описывать фичу в виде поведенческих сценариев.
		Обычно паттерн Behavior Specification используют в концепции Behavior Driven Development, которая говорит о том, что сначала мы должны специфицировать все поведение нашей функциональности, после этого мы должны ее реализовать в коде и написать падающие тесты, и в конце мы получим работающие тесты на низком уровне, поведенческие сценарии на высоком уровне, и все будут счастливы.

	17. Steps
		Когда вы используете логически сценарий, он состоит из шагов. Когда вы реализуете его в коде, зачастую шаги теряются – появляются вызовы каких-то технических деталей, подготовка данных, еще что-то, и очень непросто среди этого вычленить шаги.



